/*
 * bms.c
 *
 *  Created on: Nov 29, 2025
 *      Author: finja
 */


#include "bms.h"
#include "main.h"
#include "LTC6811.h"
#include "stdio.h"
#include "stdlib.h"
#include "math.h"
#include "can.h"
#include "adc.h"
#include "string.h"
#include "define.h"
#include "gpio.h"
#include "usb_control.h"

uint8_t precharge = 0;

extern uint8_t charging;

uint16_t ts_volt_can = 0;
uint16_t blancing_Voltage = 42000;
uint16_t max_voltage = MAX_VOLTAGE;
uint16_t balanceMargin = 100; //in 0.1mV
uint8_t volt_stamp = 0;
uint8_t temp_stamp = 0;
uint8_t imd_stamp = 0;

uint8_t IMD_ERROR = 0;
uint8_t AMS_ERROR = 0;
uint8_t PEC_ERROR = 0;

extern uint8_t ts_on;
extern uint8_t ts_start;
extern uint8_t sc_state;
extern uint16_t current;

uint32_t ICValue = 0;
float Duty = 0;
uint16_t imdStatValue = 0;
uint8_t IMDcheck = 0;

uint16_t cellVoltages[NUM_CELLS] = {0};	//cell voltages in 0.1[mV]
int16_t cellTemperatures[NUM_CELLS] = {0}; //cell temperatures in 0.1[°C]
uint8_t cfg[NUM_STACK][6] = {{0}}; //0x38 disables the GPIO1..3 pulldown so GPIO1..3 can be used for measurement
uint16_t slaveGPIOs[NUM_GPIO] = {0};
uint16_t temperature[NUM_CELLS] = {0};

uint8_t AMS0_databytes[8];
uint8_t AMS1_databytes[8];


uint16_t OV_flag[NUM_STACK];
uint16_t UV_flag[NUM_STACK];
uint8_t r_statb[NUM_STACK][6];

uint32_t can_cnt = 0; //can counter to adjust timings
uint64_t last20 =0;
uint64_t last100 =0;
uint64_t last500 = 0;
uint32_t volt_error_time = 0;
uint32_t temp_error_time = 0;
uint32_t pec_error_time = 0;
extern uint32_t ivt_error_time;

uint8_t temp_error = 0;
uint8_t count_selTemp = 0;

uint32_t current_time = 0;

uint8_t index_i = 0;
uint8_t index_k = 0;
uint8_t cell_number_temp_min = 0;
uint8_t cell_number_temp_max = 0;
uint8_t cell_number_volt_min = 0;
uint8_t cell_number_volt_max = 0;

extern uint8_t RDSTAT[8];

extern uint8_t dc_current[8];

uint8_t data_shit[3] = {0x03, 0x00, 0x00};
//uint8_t data_shit[2] = {0x03, 0x07};
char broadcaster [10]= "";

/* 1 ms interrupt
 * HLCK 96 MHz
 * APB1 48 MHz
 */
void HAL_TIM_PeriodElapsedCallback_LTC(TIM_HandleTypeDef *htim)
{
	CAN_interrupt();
}

void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
    CAN_RX(hcan1);
    CAN_RX_IVT(hcan2);
}

void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
	if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2)  // If the interrupt is triggered by channel 1
	{
		// Read the IC value
		ICValue = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2);
		if(ICValue != 0){
			Duty = 100 - (HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1) * 100.0)/ICValue; // calculate the Duty Cycle
		}
	}
	if(Duty < 10) {
		Duty = 10;
	}
	else if(Duty > 90){
		Duty = 90;
	}

	imdStatValue = (90.0*1200)/(Duty-5.0) - 1200;		//R_F = (90% * 1200kOhm)/(duty[%] - 5%) - 1200kOhm
}

void BMS_init()
{
	LTC6811_initialize();
}

void BMS()		// Battery Management System function for main loop.
{
	uint8_t pec = 0;
	static uint8_t selTemp = 0;

	LTC6811_wrcfg((uint8_t(*)[6])cfg);		// Write config
	HAL_Delay(3);

	LTC6811_clraux();		// Write config
	HAL_Delay(3);

	LTC6811_adstat();										// measure voltages
	HAL_Delay(10);

	///for (int i = 0; i < 8; i++) RDAUXA[i] = 0x00;

	uint8_t stA[8];
	int16_t temp_c10;

	int8_t pec_ok = LTC6811_rdstat(0, stA);

	if (pec_ok == 0)
	{
	    uint16_t itmp = (uint16_t)stA[2] | ((uint16_t)stA[3] << 8);
	    temp_c10 = (int16_t)(((int32_t)itmp * 2 + 7) / 15 - 2730); // 0.1°C
	}
	else
	{
	    temp_c10 = (int16_t)0x7FFF;  // ungültig
	    PEC_ERROR = 1;
	}

	/* 3-Byte Payload: ID + int16 Temperatur */
	uint8_t data_shit[3];
	data_shit[0] = 0x03;                       // ID (z.B. slave temp)
	data_shit[1] = (uint8_t)(temp_c10 & 0xFF);
	data_shit[2] = (uint8_t)(temp_c10 >> 8);

/*
	pec = LTC6811_rdstat(0, RDSTAT);	//read voltages
	HAL_Delay(3);

	int16_t temp_c10;

	if (pec == 0)
	{
	    uint16_t itmp = (uint16_t)RDSTAT[2] | ((uint16_t)RDSTAT[3] << 8);
	    temp_c10 = (int16_t)(((int32_t)itmp * 2 + 7) / 15 - 2730); // 0.1°C
	}
	else
	{
	    temp_c10 = (int16_t)0x7FFF;   // ungültig markieren
	    PEC_ERROR = 1;                // optional
	}

	// Jetzt Temperatur senden (statt itmp)
	data_shit[0] = 0x03;
	data_shit[1] = (uint8_t)(temp_c10 & 0xFF);
	data_shit[2] = (uint8_t)(((uint16_t)temp_c10) >> 8);
*/
	/*
	uint16_t tempC = (int16_t)(temp_c10 / 10);
	//int16_t temp_c10 = (int16_t)(((int32_t)itmp * 2 + 7) / 15 - 2730);
	// +7 ist Rundung (optional)

	uint16_t itmp = (uint16_t)RDSTAT[2] | ((uint16_t)RDSTAT[3] << 8);
	data_shit[0] = 0x03;                   // ID bleibt!
	data_shit[1] = (uint8_t)(itmp & 0xFF);  // Value Low
	data_shit[2] = (uint8_t)(itmp >> 8);    // Value High
/*
	/*
	data_shit[0] = 0x03;
	data_shit[1] = RDSTAT[4];
	*/

	strcpy(broadcaster, "slave");
	USB_control(broadcaster, data_shit, 3);
	//USB_control(broadcaster, data_shit, 3);
	//USB_control(0x03, data_shit, 3);   // 0x03 = slave

}
static void BMS_WaitMs(uint32_t ms)
{
    uint32_t start = HAL_GetTick();
    while ((HAL_GetTick() - start) < ms)
    {
    }
}





uint16_t calculateTemperature(uint16_t voltageCode, uint16_t referenceCode)		//convert temp
{

	uint16_t denom = referenceCode - voltageCode;
	//if((referenceCode - voltageCode) != 0 && voltageCode != 0)
	if (denom >= 2000 && voltageCode != 0)
	{
		uint32_t convert_R = (voltageCode * 100000)/(referenceCode - voltageCode);
		return 1000.0 / ((1.0 / 298.15) - (log(10000.0 / convert_R) / NTC_BETA)) - 273150.0;
	}
	else return 0xFFFF;
}

void CAN_interrupt()
{
	if (HAL_GetTick()>= last20 + 20)
	{
		CAN_50(AMS0_databytes);
		last20 = HAL_GetTick();
	}
	if (HAL_GetTick()>= last100 + 100)
	{
		CAN_10(AMS1_databytes);

		HAL_GPIO_TogglePin(GPIOA, WDI_Pin);		// toggle watchdog
		HAL_GPIO_TogglePin(GPIOC, LED_GN_Pin);	// toggle LED
		last100 = HAL_GetTick();
		//send_usb();
	}
}

uint16_t find_me = 0;
uint8_t test2 = 0;

void sortTemperature(uint8_t selTemp)
{
	//uint8_t indexOffset[12] = {9, 4, 11, 7, 6, 1, 0, 3, 10, 2, 5, 8};
	uint8_t indexOffset[12] = {11, 4, 1, 9, 6, 3, 0, 5, 10, 2, 7, 8};
	for(uint8_t k = 0; k < NUM_STACK; k++)
	{
		for(uint8_t j = 0; j < 3; j++)
		{
			if(selTemp == 0 && j == 0)
			{
				temperature[k * NUM_CELLS_STACK + indexOffset[j + selTemp * 3]] = 0xFFFE;
			}
			else
			{
				uint16_t curr_temp = calculateTemperature(slaveGPIOs[j + k * 6], slaveGPIOs[5 + k * NUM_GPIO_STACK]);
				temperature[k * NUM_CELLS_STACK + indexOffset[j + selTemp * 3]] = curr_temp;

			}

		}
	}
}

void convertTemperature(uint8_t selTemp)		// sort temp
{
	sortTemperature(selTemp);

	if(selTemp == 3)
	{
		static uint16_t temp_min;
		static uint16_t temp_max;

		temp_min = temperature[0];
		temp_max = temperature[0];

		static uint8_t prev_number_temp_max = 0;
		static uint8_t prev_number_temp_min = 0;

		for(uint8_t k = 0; k < NUM_STACK; k++)
			{
				for(uint8_t i = 0; i < NUM_CELLS_STACK; i++)
				{
					if(temperature[i + k * 12] > temp_max && ((i+1)%12 != 0 && (i+1)%10 != 0))
						{
							temp_max = temperature[i + k * 12];
							cell_number_temp_max = i + k * 12;
							dc_current[2] = cell_number_temp_max;
						}
					else if(temperature[i + k * 12] < temp_min && ((i+1)%12 != 0 && (i+1)%10 != 0))
					{
						temp_min = temperature[i + k * 12];
						index_i = i;
						index_k = k;
						cell_number_temp_min = i + k * 12;
						dc_current[1] = cell_number_temp_min;
					}

				/*	if ((i+1)%10 != 0) {
						usb_temperatures[i + k * 12] = temperature[i + k * 12]/1000;
					}
					else if (temperature[i + k * 12] < 60000) {
						usb_temperatures[i + k * 12] = temperature[i + k * 12]/1000;
					}*/
				}
			}

		/*
		if(!(temp_min < MIN_Temp || temp_max > MAX_Temp))
					temp_error_time = HAL_GetTick();
*/
		if(!((temp_min < MIN_Temp && prev_number_temp_min == cell_number_temp_min) || (temp_max > MAX_Temp && prev_number_temp_max == cell_number_temp_max)))
					temp_error_time = HAL_GetTick();

		if(HAL_GetTick() - temp_error_time >= temp_detect_time){
			AMS_ERROR = 1;
		}

		AMS1_databytes[4] = temp_min;
		AMS1_databytes[5] = (temp_min >> 8);
		AMS1_databytes[6] = temp_max;
		AMS1_databytes[7] = (temp_max >> 8);

		prev_number_temp_max = cell_number_temp_max;
		prev_number_temp_min = cell_number_temp_min;
	}

}

void checkPEC(uint8_t pec)
{
	if(pec != 0)
	{
		pec_error_time = HAL_GetTick();
	}
	if(HAL_GetTick() - pec_error_time >= volt_detect_time)
	{
		PEC_ERROR = 1;
	}

}

void checkIMD()
{
	uint8_t imd_error_set = 0;

	if(imdStatValue < MIN_IMD_RES && imd_error_set == 0 && imdStatValue != 0)
	{
		imd_error_set = 1;
		imd_stamp++;
	}

	if(imd_error_set == 0){
		imd_stamp = 0;
	}

	if(imd_stamp > error_max){
		IMD_ERROR = 1;
	}
}
