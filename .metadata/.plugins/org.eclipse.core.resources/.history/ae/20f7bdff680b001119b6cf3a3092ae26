/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    can.c
  * @brief   This file provides code for the configuration
  *          of the CAN instances.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "can.h"

/* USER CODE BEGIN 0 */
#include "gpio.h"
#include "main.h"
#include "gpio.h"
#include "tim.h"

extern uint8_t AMS0_databytes[8];
extern uint8_t AMS1_databytes[8];
extern uint8_t precharge;
extern  uint16_t adc_accu_volt;
extern uint16_t imdStatValue ;
uint8_t DIC0_databytes[8];
uint8_t dc_current[8];
uint32_t current_data = 0;
uint16_t current = 0;
uint8_t ts_on = 0;
uint8_t ts_start = 0;
uint8_t charging = 0;
uint8_t ams_status = 0;
uint8_t switch_on = 0;
uint32_t capacity_data = 0;

extern uint16_t ts_volt_can;


extern uint8_t ts_ready ;
extern uint8_t IMD_ERROR;
extern uint8_t AMS_ERROR;

uint32_t ivt_error_time = 0;

uint8_t counter = 0;
CAN_TxHeaderTypeDef TxHeader;
uint8_t TxData[8];
uint32_t TxMailbox;
uint32_t TxMailbox2;

#define STOP 0
#define RUN 1

#define IVT_MSG_RESULT_T 4
#define IVT_MSG_RESULT_W 5
#define IVT_MSG_RESULT_As 6
#define IVT_MSG_RESULT_Wh 7

CAN_TxHeaderTypeDef AMS0_header = {0x200, 0, CAN_ID_STD, CAN_RTR_DATA, 8};
CAN_TxHeaderTypeDef AMS1_header = {0x201, 0, CAN_ID_STD, CAN_RTR_DATA, 8};
CAN_TxHeaderTypeDef AMS2_header = {0x210, 0 , CAN_ID_STD, CAN_RTR_DATA, 8};

CAN_TxHeaderTypeDef IVT_MSG_COMMAND = {0x411, 0,CAN_ID_STD, CAN_RTR_DATA,8};


// transmit CAN Message
void CAN_TX(CAN_HandleTypeDef hcan, CAN_TxHeaderTypeDef TxHeader, uint8_t* TxData)
{
	uint32_t TxMailbox;
	uint32_t freeMailboxes = HAL_CAN_GetTxMailboxesFreeLevel(&hcan);
	if(freeMailboxes > 0)
	{
		if (HAL_CAN_AddTxMessage(&hcan, &TxHeader, TxData, &TxMailbox) != HAL_OK)
		{
		    static uint8_t retries = 0;
		    if (retries < 5) {  // Maximum retries
		    	retries++;
			    CAN_TX(hcan, TxHeader, TxData);
		    } else {
		        retries = 0;  // Reset retry count after a failure
		        // Optionally, handle the failure (e.g., by logging it)
		        HAL_GPIO_WritePin(GPIOD, LED_RD_Pin, GPIO_PIN_SET);
			}
		}
		else
		{
		}
	}
	/*else
	{
		CAN_TX(hcan, TxHeader, TxData);
	}
	*/
	if (HAL_CAN_GetTxMailboxesFreeLevel(&hcan) == 0) return;

}

	// receive CAN message
void CAN_TX_IVT(CAN_HandleTypeDef hcan, CAN_TxHeaderTypeDef TxHeader, uint8_t* TxData)
{
	uint32_t TxMailbox;
	uint32_t freeMailboxes = HAL_CAN_GetTxMailboxesFreeLevel(&hcan);
	if(freeMailboxes > 0)
	{
		if (HAL_CAN_AddTxMessage(&hcan, &TxHeader, TxData, &TxMailbox) != HAL_OK)
		{
		    static uint8_t retries = 0;
		    if (retries < 5) {  // Maximum retries
		    	retries++;
			    CAN_TX_IVT(hcan, TxHeader, TxData);
		    } else {
		        retries = 0;  // Reset retry count after a failure
		        // Optionally, handle the failure (e.g., by logging it)
		        HAL_GPIO_WritePin(GPIOD, LED_RD_Pin, GPIO_PIN_SET);
			}
		}
		else
		{
		}
	}
	else
	{
		CAN_TX_IVT(hcan, TxHeader, TxData);
	}
}

void CAN_RX(CAN_HandleTypeDef hcan)
{
	CAN_RxHeaderTypeDef RxHeader;
	uint8_t RxData[8];
	if (HAL_CAN_GetRxMessage(&hcan, CAN_RX_FIFO0, &RxHeader, RxData) != HAL_OK)
	{
	}
	if( RxHeader.StdId == 0x500)		// Buttons on DIC
		{
			if((RxData[0]& 1) == 1)				// close SC
			{
				ts_on = 1;
				switch_on = 1;
			}

			charging = (RxData[0]>>7);
		}
}


void IVT_MODE(uint8_t mode)
{
	uint8_t data[8];

	data[0] = 0x34;
	data[1] = mode;
	data[2] = 0x01;
	data[3] = 0x00;
	data[4] = 0x00;
	data[5] = 0x00;
	data[6] = 0x00;
	data[7] = 0x00;

	CAN_TX_IVT(hcan2,IVT_MSG_COMMAND,data);
}

void IVT_ACTIVATE(uint8_t channel)
{
	uint8_t data [8];

	data[0] = 0x20 | channel;
	data[1] = 0x02;
	data[2] = 0x00;
	data[3] = 0x14;
	data[4] = 0x00;
	data[5] = 0x00;
	data[6] = 0x00;
	data[7] = 0x00;

	CAN_TX_IVT(hcan2,IVT_MSG_COMMAND,data);
}

void IVT_init()
{
	static uint32_t t = 0;
	static uint8_t state = 0;

	switch(state)
	{
		case 0:
	        t = HAL_GetTick();   // aktuelle Zeit merken
	        state = 1;
	        break;

	     case 1:
	        if (HAL_GetTick() - t >= 1000) {
	            IVT_MODE(STOP);
	            t = HAL_GetTick();
	            state = 2;
	        }
	        break;

	     case 2:
	    	 if (HAL_GetTick() - t >= 100) {
	    		 IVT_ACTIVATE(IVT_MSG_RESULT_As);
	    		 t = HAL_GetTick();
	    		 state = 3;
	         }
	         break;

	     case 3:
	    	 if (HAL_GetTick() - t >= 100) {
	    		 IVT_ACTIVATE(IVT_MSG_RESULT_W);
	    		 t = HAL_GetTick();
	    		 state = 4;
	         }
	         break;

	     case 4:
	    	 if (HAL_GetTick() - t >= 100) {
	    		 IVT_MODE(RUN);
	    		 state = 5;   // fertig
	    	 }
	         break;

	     case 5:
	            // done
	         break;
	}
}

void can_put_data()
{
	AMS0_databytes[0] = ts_volt_can;
	AMS0_databytes[1] = (ts_volt_can >> 8);
	AMS0_databytes[2] = current;
	AMS0_databytes[3] = (current >> 8);
	AMS0_databytes[4] = imdStatValue;
	AMS0_databytes[5] = (imdStatValue>>8);
	AMS0_databytes[6] =  0  | (ts_ready << 3) | (precharge << 4) | (IMD_ERROR << 6) | (AMS_ERROR << 7);
	AMS0_databytes[7] = ams_status;
}

void CAN_RX_IVT(CAN_HandleTypeDef hcan)
{
	CAN_RxHeaderTypeDef RxHeader;
	uint8_t RxData[8];
	if (HAL_CAN_GetRxMessage(&hcan, CAN_RX_FIFO0, &RxHeader, RxData) != HAL_OK)
	{

	}
	current_data = 0;

		if(RxHeader.StdId == 0x521)		// Current mA
		{
			current_data = RxData[5] | (RxData[4] << (1*8)) | (RxData[3] << (2*8)) | (RxData[2] << (3*8));

			if(RxData[2] >> 7 == 0)
			{
				//current = (current_data << 1 >> 1)/100;
				current = current_data/100;
			}
			else
			{
				current = ~current_data/100;
			}
			//current = current_data/100;

			ivt_error_time = HAL_GetTick();

			dc_current[4] = RxData[2];
			dc_current[5] = RxData[3];
			dc_current[6] = RxData[4];
			dc_current[7] = RxData[5];

		}
		if(RxHeader.StdId == 0x527)		// Capacity As
		{
			capacity_data = RxData[5] | (RxData[4] << (1*8)); //| (RxData[3] << (2*8)) | (RxData[2] << (3*8));

			AMS0_databytes[4] = RxData[4];
			AMS0_databytes[5] = RxData[5];
		}
}

void CAN_50(uint8_t precharge_data[])		// CAN Messages transmitted with 50 Hz
{

	CAN_TX(hcan1, AMS0_header, precharge_data);


	ams_status++;

	if(ams_status == 255)
	{
		ams_status = 0;
	}
}

void CAN_10(uint8_t bms_data[])		// CAN Messages transmitted with 10 Hz
{
	CAN_TX(hcan1, AMS1_header, bms_data);
	CAN_TX(hcan1, AMS2_header, dc_current);

	//get_ts_ready();
}


void CAN_TIM2_Tick(void)
{
	if(htim9 -> Instance == TIM2)
	{
		counter ++;

		TxData[0] = 0;
	  TxData[1] = 0;
	  TxData[2] = 0;
	  TxData[3] = 0;
	  TxData[4] = 0;
	  TxData[5] = 0;
	  TxData[6] = 0;
	  TxData[7] = 0;


	  TxHeader.DLC = 8; // Data length
	  			TxHeader.IDE = CAN_ID_STD; // Standard-ID (11-bit)
	  			TxHeader.RTR = CAN_RTR_DATA;
	  			TxHeader.StdId = 0x200; // ID
		if(counter >= 1){
			HAL_GPIO_TogglePin(LED_GN_GPIO_Port, LED_GN_Pin);

			//CAN_TX(hcan1, TxHeader, TxData);
			if (HAL_CAN_GetTxMailboxesFreeLevel(&hcan1) > 0) {
			                if (HAL_CAN_AddTxMessage(&hcan1, &TxHeader, TxData, &TxMailbox) != HAL_OK) {

			                }
			            }
			counter = 0;
		}
	}
}
/*
Senden des CAN-Datenrahmens
void CAN_TX(CAN_HandleTypeDef hcan, CAN_HandleTypeDef Txheader);
Es ist der "Handle" (Zeiger bzw. Struktur), der alle relevanten Informationen enthält, damit die HAL-Bibliothek mit der CAN-Schnittstelle arbeiten kann
if (HAL_CAN_AddTxMessage(&hcan1, &TxHeader, TxData, &TxMailbox) != HAL_OK)
{
 ErrorLed_Task ();
}
	CAN_RxHeaderTypeDef   RxHeader;
	uint8_t               RxData[8];
emfangen der Nachrichten von RX-FIFO0
	void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
	{
	  if (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, RxData) != HAL_OK)
	  {
	    ErrorLed_Task();
	  }
	  if ((RxHeader.StdId == 0x103))
	  {
		  datacheck = 1;
	  }
	}
*/



/* USER CODE END 0 */

CAN_HandleTypeDef hcan1;
CAN_HandleTypeDef hcan2;

/* CAN1 init function */
void MX_CAN1_Init(void)
{

  /* USER CODE BEGIN CAN1_Init 0 */


  /* USER CODE END CAN1_Init 0 */

  /* USER CODE BEGIN CAN1_Init 1 */

  /* USER CODE END CAN1_Init 1 */
  hcan1.Instance = CAN1;
  hcan1.Init.Prescaler = 3;
  hcan1.Init.Mode = CAN_MODE_NORMAL;
  hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;
  hcan1.Init.TimeSeg1 = CAN_BS1_13TQ;
  hcan1.Init.TimeSeg2 = CAN_BS2_2TQ;
  hcan1.Init.TimeTriggeredMode = DISABLE;
  hcan1.Init.AutoBusOff = DISABLE;
  hcan1.Init.AutoWakeUp = DISABLE;
  hcan1.Init.AutoRetransmission = DISABLE;
  hcan1.Init.ReceiveFifoLocked = DISABLE;
  hcan1.Init.TransmitFifoPriority = DISABLE;
  if (HAL_CAN_Init(&hcan1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN CAN1_Init 2 */

  //CAN_FilterTypeDef canfilterconfig_DIC;


  /*  Filter über FilterAction aktivieren
  	  Filterbänke zuweisen und auswählen
  	  Welches FIFO (FIFO0 oder FIFI1)
  	  FilterIdHigh, welche ID-Bits verglichen werden sollen
  	  FilterMaskIdHigh, Vergleich bestimmter Bits zwischen dem ID-Register und der eingehenden ID zu ermöglichen
  	  FilterMode, Maskenmodus (ausgewählte Bits vergleichen) oder Listenmodus (vollständige IDs vergleichen)
  	  Filter Scale, Verwendung eines 32-Bit-Registers oder zweier 16-Bit-Register

  canfilterconfig_DIC.FilterActivation = CAN_FILTER_ENABLE;


  canfilterconfig_DIC.FilterBank = 1;  // which filter bank to use from the assigned ones
  canfilterconfig_DIC.FilterFIFOAssignment = CAN_FILTER_FIFO0;
  canfilterconfig_DIC.FilterIdHigh = 0x0000;
  canfilterconfig_DIC.FilterIdLow = 0x0000;
  canfilterconfig_DIC.FilterMaskIdHigh = 0x0000;
  canfilterconfig_DIC.FilterMaskIdLow = 0x0000;
  canfilterconfig_DIC.FilterMode = CAN_FILTERMODE_IDMASK;	//Mask or List
  canfilterconfig_DIC.FilterScale = CAN_FILTERSCALE_32BIT;
  canfilterconfig_DIC.SlaveStartFilterBank = 20;  // how many filters to assign to the CAN1 (master can)

  HAL_CAN_ConfigFilter(&hcan1, &canfilterconfig_DIC);
*/

  CAN_FilterTypeDef canfilterconfig1;

  canfilterconfig1.FilterActivation = CAN_FILTER_ENABLE;
  canfilterconfig1.FilterBank = 0;  // which filter bank to use from the assigned ones
  canfilterconfig1.FilterFIFOAssignment = CAN_FILTER_FIFO0;
  canfilterconfig1.FilterIdHigh = 0x500<<5;
  canfilterconfig1.FilterIdLow = 0;
  canfilterconfig1.FilterMaskIdHigh = 0x7FF<<5;
  canfilterconfig1.FilterMaskIdLow = 0x0000;
  canfilterconfig1.FilterMode = CAN_FILTERMODE_IDMASK;
  canfilterconfig1.FilterScale = CAN_FILTERSCALE_32BIT;
  canfilterconfig1.SlaveStartFilterBank = 14;  // how many filters to assign to the CAN1 (master can)

  HAL_CAN_ConfigFilter(&hcan1, &canfilterconfig1);

  /* USER CODE END CAN1_Init 2 */

}
/* CAN2 init function */
void MX_CAN2_Init(void)
{

  /* USER CODE BEGIN CAN2_Init 0 */

  /* USER CODE END CAN2_Init 0 */

  /* USER CODE BEGIN CAN2_Init 1 */

  /* USER CODE END CAN2_Init 1 */
  hcan2.Instance = CAN2;
  hcan2.Init.Prescaler = 16;
  hcan2.Init.Mode = CAN_MODE_NORMAL;
  hcan2.Init.SyncJumpWidth = CAN_SJW_1TQ;
  hcan2.Init.TimeSeg1 = CAN_BS1_1TQ;
  hcan2.Init.TimeSeg2 = CAN_BS2_1TQ;
  hcan2.Init.TimeTriggeredMode = DISABLE;
  hcan2.Init.AutoBusOff = DISABLE;
  hcan2.Init.AutoWakeUp = DISABLE;
  hcan2.Init.AutoRetransmission = DISABLE;
  hcan2.Init.ReceiveFifoLocked = DISABLE;
  hcan2.Init.TransmitFifoPriority = DISABLE;
  if (HAL_CAN_Init(&hcan2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN CAN2_Init 2 */
  CAN_FilterTypeDef canfilterconfig_ivt;

    canfilterconfig_ivt.FilterActivation = CAN_FILTER_ENABLE;
    canfilterconfig_ivt.FilterBank = 14;  // which filter bank to use from the assigned ones
    canfilterconfig_ivt.FilterFIFOAssignment = CAN_FILTER_FIFO0;
    canfilterconfig_ivt.FilterIdHigh = 0x521<<5;
    canfilterconfig_ivt.FilterIdLow = 0;
    canfilterconfig_ivt.FilterMaskIdHigh = 0x7FF<<5;
    canfilterconfig_ivt.FilterMaskIdLow = 0x0000;
    canfilterconfig_ivt.FilterMode = CAN_FILTERMODE_IDMASK;
    canfilterconfig_ivt.FilterScale = CAN_FILTERSCALE_32BIT;
    canfilterconfig_ivt.SlaveStartFilterBank = 14;  // how many filters to assign to the CAN1 (master can)

    HAL_CAN_ConfigFilter(&hcan2, &canfilterconfig_ivt);

    CAN_FilterTypeDef canfilterconfig_ivt1;
    canfilterconfig_ivt1.FilterActivation = CAN_FILTER_ENABLE;
      canfilterconfig_ivt1.FilterBank = 15;  // which filter bank to use from the assigned ones
      canfilterconfig_ivt1.FilterFIFOAssignment = CAN_FILTER_FIFO0;
      canfilterconfig_ivt1.FilterIdHigh = 0x527<<5;
      canfilterconfig_ivt1.FilterIdLow = 0;
      canfilterconfig_ivt1.FilterMaskIdHigh = 0x7FF<<5;
      canfilterconfig_ivt1.FilterMaskIdLow = 0x0000;
      canfilterconfig_ivt1.FilterMode = CAN_FILTERMODE_IDMASK;
      canfilterconfig_ivt1.FilterScale = CAN_FILTERSCALE_32BIT;
      canfilterconfig_ivt1.SlaveStartFilterBank = 14;
    HAL_CAN_ConfigFilter(&hcan2, &canfilterconfig_ivt1);
  /* USER CODE END CAN2_Init 2 */

}

static uint32_t HAL_RCC_CAN1_CLK_ENABLED=0;

void HAL_CAN_MspInit(CAN_HandleTypeDef* canHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(canHandle->Instance==CAN1)
  {
  /* USER CODE BEGIN CAN1_MspInit 0 */

  /* USER CODE END CAN1_MspInit 0 */
    /* CAN1 clock enable */
    HAL_RCC_CAN1_CLK_ENABLED++;
    if(HAL_RCC_CAN1_CLK_ENABLED==1){
      __HAL_RCC_CAN1_CLK_ENABLE();
    }

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**CAN1 GPIO Configuration
    PB8     ------> CAN1_RX
    PB9     ------> CAN1_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF9_CAN1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* CAN1 interrupt Init */
    HAL_NVIC_SetPriority(CAN1_TX_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(CAN1_TX_IRQn);
    HAL_NVIC_SetPriority(CAN1_RX0_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(CAN1_RX0_IRQn);
  /* USER CODE BEGIN CAN1_MspInit 1 */

  /* USER CODE END CAN1_MspInit 1 */
  }
  else if(canHandle->Instance==CAN2)
  {
  /* USER CODE BEGIN CAN2_MspInit 0 */

  /* USER CODE END CAN2_MspInit 0 */
    /* CAN2 clock enable */
    __HAL_RCC_CAN2_CLK_ENABLE();
    HAL_RCC_CAN1_CLK_ENABLED++;
    if(HAL_RCC_CAN1_CLK_ENABLED==1){
      __HAL_RCC_CAN1_CLK_ENABLE();
    }

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**CAN2 GPIO Configuration
    PB12     ------> CAN2_RX
    PB13     ------> CAN2_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF9_CAN2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* CAN2 interrupt Init */
    HAL_NVIC_SetPriority(CAN2_TX_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(CAN2_TX_IRQn);
    HAL_NVIC_SetPriority(CAN2_RX0_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(CAN2_RX0_IRQn);
  /* USER CODE BEGIN CAN2_MspInit 1 */

  /* USER CODE END CAN2_MspInit 1 */
  }
}

void HAL_CAN_MspDeInit(CAN_HandleTypeDef* canHandle)
{

  if(canHandle->Instance==CAN1)
  {
  /* USER CODE BEGIN CAN1_MspDeInit 0 */

  /* USER CODE END CAN1_MspDeInit 0 */
    /* Peripheral clock disable */
    HAL_RCC_CAN1_CLK_ENABLED--;
    if(HAL_RCC_CAN1_CLK_ENABLED==0){
      __HAL_RCC_CAN1_CLK_DISABLE();
    }

    /**CAN1 GPIO Configuration
    PB8     ------> CAN1_RX
    PB9     ------> CAN1_TX
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_8|GPIO_PIN_9);

    /* CAN1 interrupt Deinit */
    HAL_NVIC_DisableIRQ(CAN1_TX_IRQn);
    HAL_NVIC_DisableIRQ(CAN1_RX0_IRQn);
  /* USER CODE BEGIN CAN1_MspDeInit 1 */

  /* USER CODE END CAN1_MspDeInit 1 */
  }
  else if(canHandle->Instance==CAN2)
  {
  /* USER CODE BEGIN CAN2_MspDeInit 0 */

  /* USER CODE END CAN2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_CAN2_CLK_DISABLE();
    HAL_RCC_CAN1_CLK_ENABLED--;
    if(HAL_RCC_CAN1_CLK_ENABLED==0){
      __HAL_RCC_CAN1_CLK_DISABLE();
    }

    /**CAN2 GPIO Configuration
    PB12     ------> CAN2_RX
    PB13     ------> CAN2_TX
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_12|GPIO_PIN_13);

    /* CAN2 interrupt Deinit */
    HAL_NVIC_DisableIRQ(CAN2_TX_IRQn);
    HAL_NVIC_DisableIRQ(CAN2_RX0_IRQn);
  /* USER CODE BEGIN CAN2_MspDeInit 1 */

  /* USER CODE END CAN2_MspDeInit 1 */
  }
}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */
