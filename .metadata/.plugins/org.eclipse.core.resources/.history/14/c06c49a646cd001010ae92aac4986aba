/*
 * bms.c
 *
 *  Created on: Nov 29, 2025
 *      Author: finja
 */


#include "bms.h"
#include "LTC6811.h"
#include "stdio.h"
#include "stdlib.h"
#include "math.h"
#include "can.h"
#include "adc.h"
#include "string.h"
#include "define.h"
#include "gpio.h"

uint8_t precharge = 0;

	extern uint8_t charging;

	uint8_t buttonpressed = 0;

	uint16_t ts_volt_can = 0;
	uint16_t blancing_Voltage = 42000;
	uint16_t max_voltage = MAX_VOLTAGE;
	uint16_t balanceMargin = 100; //in 0.1mV
	uint8_t volt_stamp = 0;
	uint8_t temp_stamp = 0;
	uint8_t imd_stamp = 0;

	uint8_t IMD_ERROR = 0;
	uint8_t AMS_ERROR = 0;
	uint8_t PEC_ERROR = 0;

	extern uint8_t ts_on;
	extern uint8_t ts_start;
	extern uint8_t sc_state;
	extern uint16_t current;

	uint32_t ICValue = 0;
	float Duty = 0;
	uint16_t imdStatValue = 0;
	uint8_t IMDcheck = 0;

	uint16_t cellVoltages[NUM_CELLS] = {0};	//cell voltages in 0.1[mV]
	int16_t cellTemperatures[NUM_CELLS] = {0}; //cell temperatures in 0.1[Â°C]
	uint8_t cfg[NUM_STACK][6] = {{0}}; //0x38 disables the GPIO1..3 pulldown so GPIO1..3 can be used for measurement
	uint16_t slaveGPIOs[NUM_GPIO] = {0};
	uint16_t temperature[NUM_CELLS] = {0};

	uint8_t usb_data[NUM_CELLS*2 + 2 + 1] = {0};
	uint8_t usb_voltages[NUM_CELLS_STACK*NUM_STACK] = {0};
	uint8_t usb_temperatures[NUM_CELLS_STACK*NUM_STACK] = {0};

	uint8_t AMS0_databytes[8];
	uint8_t AMS1_databytes[8];


	uint16_t OV_flag[NUM_STACK];
	uint16_t UV_flag[NUM_STACK];
	uint8_t r_statb[NUM_STACK][6];

	volatile uint32_t can_cnt = 0; //can counter to adjust timings
	volatile uint64_t last20 =0;
	volatile uint64_t last100 =0;
	volatile uint64_t last500 = 0;
	volatile uint8_t send_can_50_message = 0;
	volatile uint8_t send_can_10_message = 0;
	volatile uint8_t bms_send = 0;
	volatile uint8_t send_usb_message = 0;

	uint32_t volt_error_time = 0;
	uint32_t temp_error_time = 0;
	uint32_t pec_error_time = 0;
	extern uint32_t ivt_error_time;

	uint8_t temp_error = 0;
	uint8_t count_selTemp = 0;

	uint32_t current_time = 0;

	uint8_t index_i = 0;
	uint8_t index_k = 0;
	uint8_t cell_number_temp_min = 0;
	uint8_t cell_number_temp_max = 0;
	uint8_t cell_number_volt_min = 0;
	uint8_t cell_number_volt_max = 0;

	extern uint8_t dc_current[8];

	void BMS_init()
	{
		LTC6811_initialize();
	}


	void convertVoltage()		//convert and sort Voltages
	{
		ts_volt_can = 0;
		for(uint8_t i = 0; i < NUM_CELLS; i++)
		{
			usb_voltages[i] = cellVoltages[i]/1000;
			ts_volt_can = ts_volt_can + cellVoltages[i]/100;
		}

		static uint16_t cell_max;
		static uint16_t cell_min;

		static uint8_t prev_number_volt_max = 0;
		static uint8_t prev_number_volt_min = 0;

		cell_max = cellVoltages[0];
		cell_min = cellVoltages[0];

		//uint16_t cell_max = 26000;
		//uint16_t cell_min = 43000;

		for(uint8_t k = 0; k < NUM_STACK; k++)
		{
			for(uint8_t i = 0; i < NUM_CELLS_STACK; i++)
			{
				if(cellVoltages[i + k * 12] > cell_max && (cellVoltages[i + k * 12] < 45000 || cellVoltages[i + k * 12] > 60000) && (i+1)%12 != 0)
				{
					cell_max = cellVoltages[i + k * 12];
					cell_number_volt_max = i + k * 12;
					dc_current[3] = cell_number_volt_max;
				}
				else if(cellVoltages[i + k * 12] < cell_min && (cellVoltages[i + k * 12] > 23000 || cellVoltages[i + k * 12] < 5000) && (i+1)%12 != 0)
				{
					cell_min = cellVoltages[i + k * 12];
					cell_number_volt_min = i + k * 12;
					dc_current[0] = cell_number_volt_min;
				}
			}
		}

		if(!((cell_min < MIN_VOLTAGE && cell_number_volt_min == prev_number_volt_min) || (cell_max > MAX_VOLTAGE && cell_number_volt_max == prev_number_volt_max)))
			volt_error_time = HAL_GetTick();

		/*
		if(!(cell_max > MAX_VOLTAGE && cell_number_volt_max != prev_number_volt_max))
			volt_error_time = HAL_GetTick();
			*/

		if(HAL_GetTick() - volt_error_time >= volt_detect_time)
			AMS_ERROR = 1;

		blancing_Voltage = cell_min;
		max_voltage = cell_max;

		AMS1_databytes[0] = cell_min;
		AMS1_databytes[1] = (cell_min >> 8);
		AMS1_databytes[2] = cell_max;
		AMS1_databytes[3] = (cell_max >> 8);

		prev_number_volt_max = cell_number_volt_max;
		prev_number_volt_min = cell_number_volt_min;
	}

	uint16_t calculateTemperature(uint16_t voltageCode, uint16_t referenceCode)		//convert temp
	{

		uint16_t denom = referenceCode - voltageCode;
		//if((referenceCode - voltageCode) != 0 && voltageCode != 0)
		if (denom >= 2000 && voltageCode != 0)
		{
			uint32_t convert_R = (voltageCode * 100000)/(referenceCode - voltageCode);
			return 1000.0 / ((1.0 / 298.15) - (log(10000.0 / convert_R) / NTC_BETA)) - 273150.0;
		}
		else return 0xFFFF;
	}


	void sortTemperature(uint8_t selTemp)
	{
		//uint8_t indexOffset[12] = {9, 4, 11, 7, 6, 1, 0, 3, 10, 2, 5, 8};
		uint8_t indexOffset[12] = {11, 4, 1, 9, 6, 3, 0, 5, 10, 2, 7, 8};
		for(uint8_t k = 0; k < NUM_STACK; k++)
		{
			for(uint8_t j = 0; j < 3; j++)
			{
				if(selTemp == 0 && j == 0)
				{
					temperature[k * NUM_CELLS_STACK + indexOffset[j + selTemp * 3]] = 0xFFFE;
				}
				else
				{
					uint16_t curr_temp = calculateTemperature(slaveGPIOs[j + k * 6], slaveGPIOs[5 + k * NUM_GPIO_STACK]);
					temperature[k * NUM_CELLS_STACK + indexOffset[j + selTemp * 3]] = curr_temp;
				}

			}
		}
	}

	void convertTemperature(uint8_t selTemp)		// sort temp
	{
		sortTemperature(selTemp);

		if(selTemp == 3)
		{
			/*
			for(uint8_t i = 0; i < NUM_CELLS; i++)
			{
				usb_temperatures[i] = temperature[i]/1000;
			}
			*/

			static uint16_t temp_min;
			static uint16_t temp_max;

			temp_min = temperature[0];
			temp_max = temperature[0];

			static uint8_t prev_number_temp_max = 0;
			static uint8_t prev_number_temp_min = 0;
			//uint16_t temp_min = 30000;
			//uint16_t temp_max = 10000;

			for(uint8_t k = 0; k < NUM_STACK; k++)
				{
					for(uint8_t i = 0; i < NUM_CELLS_STACK; i++)
					{
						if(temperature[i + k * 12] > temp_max && ((i+1)%12 != 0 && (i+1)%10 != 0))
						{
							temp_max = temperature[i + k * 12];
							cell_number_temp_max = i + k * 12;
							dc_current[2] = cell_number_temp_max;
						}
						else if(temperature[i + k * 12] < temp_min && ((i+1)%12 != 0 && (i+1)%10 != 0))
						{
							temp_min = temperature[i + k * 12];
							index_i = i;
							index_k = k;
							cell_number_temp_min = i + k * 12;
							dc_current[1] = cell_number_temp_min;
						}

						if ((i+1)%10 != 0) {
							usb_temperatures[i + k * 12] = temperature[i + k * 12]/1000;
						}
						else if (temperature[i + k * 12] < 60000) {
							usb_temperatures[i + k * 12] = temperature[i + k * 12]/1000;
						}

					}
				}
	/*
			if(!(temp_min < MIN_Temp || temp_max > MAX_Temp))
						temp_error_time = HAL_GetTick();
	*/
			if(!((temp_min < MIN_Temp && prev_number_temp_min == cell_number_temp_min) || (temp_max > MAX_Temp && prev_number_temp_max == cell_number_temp_max)))
						temp_error_time = HAL_GetTick();

			if(HAL_GetTick() - temp_error_time >= temp_detect_time){
				AMS_ERROR = 1;
			}

			AMS1_databytes[4] = temp_min;
			AMS1_databytes[5] = (temp_min >> 8);
			AMS1_databytes[6] = temp_max;
			AMS1_databytes[7] = (temp_max >> 8);

			prev_number_temp_max = cell_number_temp_max;
			prev_number_temp_min = cell_number_temp_min;
		}

	}
