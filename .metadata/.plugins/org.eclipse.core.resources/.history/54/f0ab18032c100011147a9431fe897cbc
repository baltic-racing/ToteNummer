/*
 * bms.c
 *
 *  Created on: Nov 29, 2025
 *      Author: finja
 */


#include "bms.h"
#include "main.h"
#include "LTC6811.h"
#include "stdio.h"
#include "stdlib.h"
#include "math.h"
#include "can.h"
#include "adc.h"
#include "string.h"
#include "define.h"
#include "gpio.h"
#include "usb_control.h"

uint8_t precharge = 0;

extern uint8_t charging;

uint16_t ts_volt_can = 0;
uint16_t blancing_Voltage = 42000;
uint16_t max_voltage = MAX_VOLTAGE;
uint16_t balanceMargin = 100; //in 0.1mV
uint8_t volt_stamp = 0;
uint8_t temp_stamp = 0;
uint8_t imd_stamp = 0;

uint8_t IMD_ERROR = 0;
uint8_t AMS_ERROR = 0;
uint8_t PEC_ERROR = 0;

extern uint8_t ts_on;
extern uint8_t ts_start;
extern uint8_t sc_state;
extern uint16_t current;

uint32_t ICValue = 0;
float Duty = 0;
uint16_t imdStatValue = 0;
uint8_t IMDcheck = 0;

uint16_t cellVoltages[NUM_CELLS] = {0};	//cell voltages in 0.1[mV]
int16_t cellTemperatures[NUM_CELLS] = {0}; //cell temperatures in 0.1[°C]
uint8_t cfg[NUM_STACK][6] = {{0}}; //0x38 disables the GPIO1..3 pulldown so GPIO1..3 can be used for measurement
uint16_t slaveGPIOs[NUM_GPIO] = {0};
uint16_t temperature[NUM_CELLS] = {0};

uint8_t AMS0_databytes[8];
uint8_t AMS1_databytes[8];


uint16_t OV_flag[NUM_STACK];
uint16_t UV_flag[NUM_STACK];
uint8_t r_statb[NUM_STACK][6];

uint32_t can_cnt = 0; //can counter to adjust timings
uint64_t last20 =0;
uint64_t last100 =0;
uint64_t last500 = 0;
uint32_t volt_error_time = 0;
uint32_t temp_error_time = 0;
uint32_t pec_error_time = 0;
extern uint32_t ivt_error_time;

uint8_t temp_error = 0;
uint8_t count_selTemp = 0;

uint32_t current_time = 0;

uint8_t index_i = 0;
uint8_t index_k = 0;
uint8_t cell_number_temp_min = 0;
uint8_t cell_number_temp_max = 0;
uint8_t cell_number_volt_min = 0;
uint8_t cell_number_volt_max = 0;

extern uint8_t RDSTAT[4];
extern uint8_t dc_current[8];

//extern uint8_t RDAUXA[8];
//uint8_t data_shit[2] = {0x03, 0x07};

char broadcaster [10]= "";
/* 1 ms interrupt
 * HLCK 96 MHz
 * APB1 48 MHz
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	if (htim->Instance == TIM2)
	    {
	        CAN_interrupt();   // eure Logik
	        //CAN_TIM2_Tick();   // eure can.c Tick-Funktion
	    }
}

void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
    CAN_RX(hcan1);
    CAN_RX_IVT(hcan2);
}

void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
	if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2)  // If the interrupt is triggered by channel 1
	{
		// Read the IC value
		ICValue = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2);
		if(ICValue != 0){
			Duty = 100 - (HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1) * 100.0)/ICValue; // calculate the Duty Cycle
		}
	}
	if(Duty < 10) {
		Duty = 10;
	}
	else if(Duty > 90){
		Duty = 90;
	}

	imdStatValue = (90.0*1200)/(Duty-5.0) - 1200;		//R_F = (90% * 1200kOhm)/(duty[%] - 5%) - 1200kOhm
}

void BMS_init()
{
	LTC6811_initialize();
}

void BMS()		// Battery Management System function for main loop.
{
	void BMS()
	{
	    HAL_GPIO_TogglePin(LED_GN_GPIO_Port, LED_GN_Pin);  // grüne LED toggelt bei jedem Aufruf
	    static uint32_t last_usb = 0;
	    if (HAL_GetTick() - last_usb < 100) return;
	    last_usb = HAL_GetTick();

	    uint8_t triplet[3] = {0x03, 0x01, 0x2C};
	    USB_control("slave", triplet, 3);
	}
	/*
    static uint32_t last_usb = 0;
    uint8_t stA[8] = {0};

    if (HAL_GetTick() - last_usb < 100) return;
    last_usb = HAL_GetTick();

    LTC6811_adstat();
    HAL_Delay(5);

    if (LTC6811_rdstat(0, stA) == 0)   // 0 = IC-Adresse (bei einem Chip)
    {
        uint16_t itmp = (uint16_t)stA[2] | ((uint16_t)stA[3] << 8);

        uint8_t triplet[3];
        triplet[0] = 0x03;               // ID für LTC-Temperatur
        triplet[1] = (uint8_t)(itmp >> 8); // High-Byte
        triplet[2] = (uint8_t)(itmp & 0xFF); // Low-Byte

        USB_control("slave", triplet, 3);
    }
    else
    {
        // Bei PEC-Fehler sende einen Fehlerwert (z.B. 0xFFFF)
        uint8_t triplet[3] = {0x03, 0xFF, 0xFF};
        USB_control("slave", triplet, 3);
    }

    if (LTC6811_rdstat(0, stA) != 0) {
        HAL_GPIO_TogglePin(LED_RD_GPIO_Port, LED_RD_Pin); // rote LED toggelt bei Fehler
    }*/
	/*
	static uint32_t last_usb = 0;
	if (HAL_GetTick() - last_usb < 100) return;   // nur alle 100ms (10Hz)
	last_usb = HAL_GetTick();
	uint8_t stA[8] = {0};
	int16_t temp_c10 = 0x7FFF;			// Default: Fehlerwert (wichtig!)

	LTC6811_wrcfg((uint8_t(*)[6])cfg);		// Write config
	HAL_Delay(3);
	LTC6811_clrstat();
	HAL_Delay(2);
	LTC6811_adstat();
	HAL_Delay(20);
	// Status Register A lesen (ITMP liegt in Byte 2 und 3)
	if (LTC6811_rdstat(0, stA) == 0)
	{
		uint16_t itmp = (uint16_t)stA[2] | ((uint16_t)stA[3] << 8);
		temp_c10 = (int16_t)(((int32_t)itmp * 10 + 37) / 75 - 2730); // 0.1°C
		PEC_ERROR = 0;
	}
	else
	{
		temp_c10 = 0x7FFF;
		PEC_ERROR = 1;
	}

	uint8_t payload[3];
	uint16_t temp_u16 = (uint16_t)temp_c10;   // 16-Bit Wert (0.1°C)
	payload[0] = 0x03;                        // ID: LTC_Internal_Temp
	payload[1] = (uint8_t)(temp_u16 >> 8);   // High Byte
	payload[2] = (uint8_t)(temp_u16 & 0xFF); // Low Byte
	USB_control("slave", payload, sizeof(payload)); // = 3
	*/

}

static void BMS_WaitMs(uint32_t ms)
{
    uint32_t start = HAL_GetTick();
    while ((HAL_GetTick() - start) < ms)
    {
    }
}

uint16_t calculateTemperature(uint16_t voltageCode, uint16_t referenceCode)		//convert temp
{

	uint16_t denom = referenceCode - voltageCode;
	//if((referenceCode - voltageCode) != 0 && voltageCode != 0)
	if (denom >= 2000 && voltageCode != 0)
	{
		uint32_t convert_R = (voltageCode * 100000)/(referenceCode - voltageCode);
		return 1000.0 / ((1.0 / 298.15) - (log(10000.0 / convert_R) / NTC_BETA)) - 273150.0;
	}
	else return 0xFFFF;
}

void CAN_interrupt()
{
	if (HAL_GetTick()>= last20 + 20)
	{
		can_put_data();           // <-- DAS FEHLT
		CAN_50(AMS0_databytes);
		last20 = HAL_GetTick();
	}
	if (HAL_GetTick()>= last100 + 100)
	{
		CAN_10(AMS1_databytes);

		HAL_GPIO_TogglePin(GPIOA, WDI_Pin);		// toggle watchdog
		//HAL_GPIO_TogglePin(GPIOC, LED_GN_Pin);	// toggle LED
		last100 = HAL_GetTick();
		//send_usb();
	}
}

uint16_t find_me = 0;
uint8_t test2 = 0;

void sortTemperature(uint8_t selTemp)
{
	//uint8_t indexOffset[12] = {9, 4, 11, 7, 6, 1, 0, 3, 10, 2, 5, 8};
	uint8_t indexOffset[12] = {11, 4, 1, 9, 6, 3, 0, 5, 10, 2, 7, 8};
	for(uint8_t k = 0; k < NUM_STACK; k++)
	{
		for(uint8_t j = 0; j < 3; j++)
		{
			if(selTemp == 0 && j == 0)
			{
				temperature[k * NUM_CELLS_STACK + indexOffset[j + selTemp * 3]] = 0xFFFE;
			}
			else
			{
				uint16_t curr_temp = calculateTemperature(slaveGPIOs[j + k * 6], slaveGPIOs[5 + k * NUM_GPIO_STACK]);
				temperature[k * NUM_CELLS_STACK + indexOffset[j + selTemp * 3]] = curr_temp;

			}

		}
	}
}

void convertTemperature(uint8_t selTemp)		// sort temp
{
	sortTemperature(selTemp);

	if(selTemp == 3)
	{
		static uint16_t temp_min;
		static uint16_t temp_max;

		temp_min = temperature[0];
		temp_max = temperature[0];

		static uint8_t prev_number_temp_max = 0;
		static uint8_t prev_number_temp_min = 0;

		for(uint8_t k = 0; k < NUM_STACK; k++)
			{
				for(uint8_t i = 0; i < NUM_CELLS_STACK; i++)
				{
					if(temperature[i + k * 12] > temp_max && ((i+1)%12 != 0 && (i+1)%10 != 0))
						{
							temp_max = temperature[i + k * 12];
							cell_number_temp_max = i + k * 12;
							dc_current[2] = cell_number_temp_max;
						}
					else if(temperature[i + k * 12] < temp_min && ((i+1)%12 != 0 && (i+1)%10 != 0))
					{
						temp_min = temperature[i + k * 12];
						index_i = i;
						index_k = k;
						cell_number_temp_min = i + k * 12;
						dc_current[1] = cell_number_temp_min;
					}

				/*	if ((i+1)%10 != 0) {
						usb_temperatures[i + k * 12] = temperature[i + k * 12]/1000;
					}
					else if (temperature[i + k * 12] < 60000) {
						usb_temperatures[i + k * 12] = temperature[i + k * 12]/1000;
					}*/
				}
			}

		/*
		if(!(temp_min < MIN_Temp || temp_max > MAX_Temp))
					temp_error_time = HAL_GetTick();
		 */
		if(!((temp_min < MIN_Temp && prev_number_temp_min == cell_number_temp_min) || (temp_max > MAX_Temp && prev_number_temp_max == cell_number_temp_max)))
					temp_error_time = HAL_GetTick();

		if(HAL_GetTick() - temp_error_time >= temp_detect_time){
			AMS_ERROR = 1;
		}

		AMS1_databytes[4] = temp_min;
		AMS1_databytes[5] = (temp_min >> 8);
		AMS1_databytes[6] = temp_max;
		AMS1_databytes[7] = (temp_max >> 8);

		prev_number_temp_max = cell_number_temp_max;
		prev_number_temp_min = cell_number_temp_min;
	}

}

void checkPEC(uint8_t pec)
{
	if(pec != 0)
	{
		pec_error_time = HAL_GetTick();
	}
	if(HAL_GetTick() - pec_error_time >= volt_detect_time)
	{
		PEC_ERROR = 1;
	}

}

void checkIMD()
{
	uint8_t imd_error_set = 0;

	if(imdStatValue < MIN_IMD_RES && imd_error_set == 0 && imdStatValue != 0)
	{
		imd_error_set = 1;
		imd_stamp++;
	}

	if(imd_error_set == 0){
		imd_stamp = 0;
	}

	if(imd_stamp > error_max){
		IMD_ERROR = 1;
	}
}
